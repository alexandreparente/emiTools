# -*- coding: utf-8 -*-

"""
/***************************************************************************
 emiTools
                                 A QGIS plugin
 This plugin compiles tools used by EMI-PB
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-10
        copyright            : (C) 2024 by Alexandre Parente Lima
        email                : alexandre.parente@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Alexandre Parente Lima'
__date__ = '2024-10-10'
__copyright__ = '(C) 2024 by Alexandre Parente Lima'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

# -*- coding: utf-8 -*-

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing, QgsVectorFileWriter,
                       QgsProcessingAlgorithm, 
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterField, 
                       QgsProcessingParameterFile,
                       QgsProcessingParameterEnum, 
                       QgsProcessingParameterBoolean,
                       QgsProcessingException, 
                       QgsProject, QgsVectorLayer,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterVectorLayer)
                       
import os
import zipfile
from datetime import datetime

def tr(string):
    return QCoreApplication.translate('@default', string)

class emiToolsExportTerms(QgsProcessingAlgorithm):
    def initAlgorithm(self, config=None):
        # Input layer parameter
        self.addParameter(QgsProcessingParameterFeatureSource('layer', tr('Layer name:'), [QgsProcessing.TypeVectorPolygon]))
        
        # Parameter to select the field for the embargo term number
        self.addParameter(QgsProcessingParameterField('num_tei_field', tr('Embargo term field:'), parentLayerParameterName='layer', type=QgsProcessingParameterField.String, defaultValue='numero_tad'))
        
        # Parameter to select the field for the embargo term series
        self.addParameter(QgsProcessingParameterField('serie_tei_field', tr('Embargo term series field:'), parentLayerParameterName='layer', type=QgsProcessingParameterField.String, defaultValue='serie_tad'))
        
        # Setting the default output folder to the user's home directory
        default_output_folder = os.path.expanduser("~")
        self.addParameter(QgsProcessingParameterFile('output_folder', tr('Output folder:'), behavior=QgsProcessingParameterFile.Folder, defaultValue=default_output_folder))
        
        # Parameter to choose the output format
        self.addParameter(QgsProcessingParameterEnum('output_format', tr('Output file format:'), options=['ESRI Shapefile', 'GeoPackage', 'Keyhole Markup Language'], defaultValue=0))
        
        # Add parameter to export all features to a single file
        self.addParameter(QgsProcessingParameterBoolean('export_all_to_single', tr('Export all features to a single file'), defaultValue=False))
       
        # Parameter to compress the output file
        self.addParameter(QgsProcessingParameterBoolean('compress_output', tr('Compress output file copy (.zip)'), defaultValue=False))
        
        # Parameter to load the output file
        self.addParameter(QgsProcessingParameterBoolean('load_output', tr('Open output files after executing the algorithm'), defaultValue=True))

    def processAlgorithm(self, parameters, context, feedback):
        feedback = QgsProcessingMultiStepFeedback(7, feedback)
        results = {}  
       
        # Get the input layer as a feature source
        layer = self.parameterAsSource(parameters, 'layer', context)
        if layer is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, 'layer'))

        # parameters
        extracted_features = list(layer.getFeatures())
        num_tei_field = parameters['num_tei_field']              
        serie_tei_field = parameters['serie_tei_field']              
        export_all_to_single = self.parameterAsBoolean(parameters, 'export_all_to_single', context)
        output_folder = parameters['output_folder']
        output_format = self.parameterAsEnum(parameters, 'output_format', context)
        compress_output = self.parameterAsBoolean(parameters, 'compress_output', context)
        output_files = []
        today_str = "lote" + datetime.today().strftime('%Y%m%d')       
        
        # Check for duplicate features with the same embargo number    
        self.check_duplicates(extracted_features, num_tei_field)
        
        # Create a temporary layer
        temp_layer = QgsVectorLayer("Polygon?crs=EPSG:4326", "temp_layer", "memory")
        provider = temp_layer.dataProvider()
    
        # Add the existing fields from the input layer to the temporary layer
        provider.addAttributes(layer.fields())
        temp_layer.updateFields()
    
        # Add the features to the temporary layer
        for feature in extracted_features:
            provider.addFeature(feature)
              
        # Remove fields, keeping only numero_tad and serie_tad
        filtered_layer = self.remover_fields(temp_layer, num_tei_field, serie_tei_field)
        
        # Rename the fields
        filtered_layer = self.rename_fields(filtered_layer, num_tei_field, serie_tei_field)

        # Get parameters     
        if export_all_to_single:
            output_files = self.export_single_file(filtered_layer, output_folder, today_str, output_format)
        else:
            output_files = self.export_individual_files(filtered_layer, output_folder, output_format)

        # Load exported files into the project
        if self.parameterAsBoolean(parameters, 'load_output', context):
           self.load_output_files(output_files)
    
        # Compress the files if the option is checked
        if compress_output:
            self.compress_files(output_files, output_format, export_all_to_single, output_folder, feedback)
    
        return results
        
    def check_duplicates(self, extracted_features, num_tei_field):
        tad_numbers = [f[num_tei_field] for f in extracted_features]      
        duplicated_tads = {tad_number: tad_numbers.count(tad_number) for tad_number in set(tad_numbers) if tad_numbers.count(tad_number) > 1}
        if duplicated_tads:
            raise QgsProcessingException(tr(f"More than one feature associated with the embargo term number was found: {list(duplicated_tads.keys())}. Feature count: {len(extracted_features)}."))

    def remover_fields(self, layer, num_tei_field, serie_tei_field):
        # Fields that should be kept
        fields_to_keep = [num_tei_field, serie_tei_field]
    
        provider = layer.dataProvider()
    
        # Collect indexes of fields to be removed
        fields_to_remove = [layer.fields().indexOf(field.name()) for field in layer.fields() if field.name() not in fields_to_keep]
    
        # Remove the fields
        if fields_to_remove:
            provider.deleteAttributes(fields_to_remove)
          
        # Update the layer's fields
        layer.updateFields()
        return layer

    def rename_fields(self, layer, num_tei_field, serie_tei_field):
        # Renaming dictionary
        field_renames = {
            num_tei_field: 'NUM_TEI',
            serie_tei_field: 'SERIE_TEI'
        }
    
        provider = layer.dataProvider()
    
        # Rename the fields
        for old_name, new_name in field_renames.items():
            if layer.fields().indexOf(old_name) != -1:  # Check if the field exists
                provider.renameAttributes({layer.fields().indexOf(old_name): new_name})
    
        # Update the layer's fields
        layer.updateFields()             
    
        return layer

    def export_single_file(self, layer, output_folder, today_str, output_format):
        output_files = []
        output_file = os.path.join(output_folder, f"TEI_{today_str}_sicafi.{self.get_extension(output_format)}")
        QgsVectorFileWriter.writeAsVectorFormat(layer, output_file, "UTF-8", layer.crs(), self.get_output_format_string(output_format))
        output_files.append(output_file)
        return output_files

    def export_individual_files(self, layer, output_folder, output_format):
        output_files = []
        for i, feature in enumerate(layer.getFeatures()):
            output_layer = QgsVectorLayer("Polygon?crs=EPSG:4326", f"Extracted_{i+1}", "memory")
            provider = output_layer.dataProvider()
            provider.addAttributes(layer.fields())
            output_layer.updateFields()
            provider.addFeature(feature)

            tad_number = feature[layer.fields().indexOf('NUM_TEI')]
               
            output_file = os.path.join(output_folder, f"TEI_{tad_number}_sicafi.{self.get_extension(output_format)}")
            QgsVectorFileWriter.writeAsVectorFormat(output_layer, output_file, "UTF-8", output_layer.crs(), self.get_output_format_string(output_format))
            output_files.append(output_file)
        return output_files

    def load_output_files(self, output_files):
        for output_file in output_files:
            layer_name = os.path.basename(output_file)
            QgsProject.instance().addMapLayer(QgsVectorLayer(output_file, layer_name, "ogr"))

    def compress_files(self, output_files, output_format, export_all_to_single, output_folder, feedback):
        # Defining the associated extensions based on the output format
        if output_format == 0:  # ESRI Shapefile
            associated_extensions = ['shp', 'shx', 'dbf', 'prj', 'cpg']
            file_extension = 'shp'
        elif output_format == 1:  # GeoPackage
            associated_extensions = ['gpkg']
            file_extension = 'gpkg'
        elif output_format == 2:  # KML
            associated_extensions = ['kml']
            file_extension = 'kml'
    
        for output_file in output_files:
            base_name = os.path.splitext(os.path.basename(output_file))[0]
            zip_output_file = os.path.join(output_folder, f"{base_name}.{file_extension}.zip")  # Includes the file extension
    
            associated_files = [os.path.join(output_folder, f"{base_name}.{ext}") for ext in associated_extensions if os.path.exists(os.path.join(output_folder, f"{base_name}.{ext}"))]
    
            if associated_files:
                with zipfile.ZipFile(zip_output_file, 'w') as zipf:
                    for file in associated_files:
                        zipf.write(file, os.path.basename(file))
                        
                    feedback.pushInfo(tr(f"Compressed files: {zip_output_file}"))
    
    def get_extension(self, output_format):
        if output_format == 0:  # ESRI Shapefile
            return "shp"
        elif output_format == 1:  # GeoPackage
            return "gpkg"
        elif output_format == 2:  # KML
            return "kml"

    def get_output_format_string(self, output_format):
        if output_format == 0:
            return "ESRI Shapefile"
        elif output_format == 1:
            return "GPKG"
        elif output_format == 2:
            return "KML"

    def name(self):
        return "emiToolsExportTerms"

    def displayName(self):
        return tr("Export Terms to Sicafi")

    def group(self):
        return tr("Emi Functions")

    def groupId(self):
        return ""

    #def shortHelpString(self):
    #    return tr("This algorithm exports features to the Sicafi system in different formats.")

    #def helpUrl(self):
    #    return ""

    def createInstance(self):
        return emiToolsExportTerms()
        

# -*- coding: utf-8 -*-

"""
/***************************************************************************
 emiTools
                                 A QGIS plugin
 This plugin compiles tools used by EMI-PB
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-10
        copyright            : (C) 2024 by Alexandre Parente Lima
        email                : alexandre.parente@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Alexandre Parente Lima'
__date__ = '2024-10-10'
__copyright__ = '(C) 2024 by Alexandre Parente Lima'

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsVectorFileWriter,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterField,
                       QgsProcessingParameterBoolean,
                       QgsProcessingMultiStepFeedback,
                       QgsProcessingParameterFolderDestination,
                       QgsProject,
                       QgsVectorLayer,
                       QgsFeature,
                       QgsProcessingException,
                       QgsWkbTypes,
                       QgsCoordinateTransform,
                       QgsCoordinateReferenceSystem)

import os
import zipfile
import tempfile
from .emi_tools_util import tr


class emiToolsExportKmlRpa(QgsProcessingAlgorithm):

    # Definition of input and output parameters
    OUTPUT_FOLDER = 'OUTPUT_FOLDER'

    def initAlgorithm(self, config=None):
        # Input layer parameter using QgsProcessingParameterFeatureSource
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                'layer',
                tr('Input layer'),
                [QgsProcessing.TypeVectorPolygon, QgsProcessing.TypeVectorLine]
            )
        )
        
        # Input field parameter to select a field for naming the exported files
        self.addParameter(
            QgsProcessingParameterField(
                'export_field',
                tr('Export file name field'),
                '', 'layer', optional=True
            )
        )

        # Output folder parameter
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT_FOLDER,
                tr('Output folder')
            )
        )
        
        # Option to compress the output
        self.addParameter(
            QgsProcessingParameterBoolean(
                'compress_output',
                tr('Compress output file copy (.zip)'),
                defaultValue=False
            )
        )

        # Option to load the output into the project
        self.addParameter(
            QgsProcessingParameterBoolean(
                'load_output',
                tr('Open output files after executing the algorithm'),
                defaultValue=True
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        layer = self.parameterAsSource(parameters, 'layer', context)
        if layer is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, 'layer'))

        # Get the field selected by the user
        export_field = self.parameterAsString(parameters, 'export_field', context)

	    # Get output folder
        output_folder = self.parameterAsString(parameters, self.OUTPUT_FOLDER, context)
        compress_output = self.parameterAsBoolean(parameters, 'compress_output', context)
        load_output = self.parameterAsBoolean(parameters, 'load_output', context)

        if not output_folder:
            output_folder = tempfile.mkdtemp()
            
        # Try to create the folder if it doesn't exist
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        output_files = []

        source_crs = layer.sourceCrs()
        dest_crs = QgsCoordinateReferenceSystem('EPSG:4326')
        transform = QgsCoordinateTransform(source_crs, dest_crs, QgsProject.instance())

        total_features = layer.featureCount()
        if total_features == 0:
            feedback.pushInfo(tr("No features to process."))
            return {self.OUTPUT_FOLDER: output_folder}

        features = layer.getFeatures()
        for i, feature in enumerate(features):
            if feedback.isCanceled():
                break

            field_value = feature[export_field] if export_field and feature[
                export_field] else f"{layer.sourceName()}_{feature.id()}"

            geometry = feature.geometry()
            if not geometry or geometry.isEmpty():
                feedback.pushInfo(f"Skipping feature {feature.id()}: No valid geometry found.")
                continue

            geometry.transform(transform)

            geometries = [geometry] if not geometry.isMultipart() else geometry.asGeometryCollection()

            # Processes each part of the geometry
            for j, singlepart_geometry in enumerate(geometries):
                part_suffix = f"_{j + 1}" if len(geometries) > 1 else ""
                file_name = f"{field_value}{part_suffix}"
                output_file = os.path.join(output_folder, f"{file_name}.kml")

                try:
                    self.write_geometry_to_kml(singlepart_geometry, file_name, output_file)
                    output_files.append(output_file)
                except Exception as e:
                    feedback.reportError(f"Could not write KML for {file_name}: {e}")

            feedback.setProgress((i + 1) / total_features * 100)

        feedback.pushInfo(f"Total files generated: {len(output_files)}")

        if compress_output and output_files:
            for output_file in output_files:
                self.compress_files(output_file)

        if load_output and output_files:
            self.load_output_files(output_files)

        return {self.OUTPUT_FOLDER: output_folder}

    def write_geometry_to_kml(self, geom, name, output_path):
        """Constrói um KML manualmente sem uso da tag <Folder> utilizada pela API do QGIS."""

        kml = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<kml xmlns="http://www.opengis.net/kml/2.2">',
            '<Document>',
            '<Placemark>',
            f'<name>{name}</name>'
        ]

        geom_type = QgsWkbTypes.geometryType(geom.wkbType())

        # O método asGeometryCollection retorna geometrias simples,

        if geom_type == QgsWkbTypes.PolygonGeometry:
            polygon = geom.get()
            kml.append('<Polygon>')

            exterior = polygon.exteriorRing()
            if exterior:
                coords = " ".join([f"{v.x()},{v.y()},0" for v in exterior.vertices()])
                kml.append(
                    f'<outerBoundaryIs><LinearRing><coordinates>{coords}</coordinates></LinearRing></outerBoundaryIs>')

            for i in range(polygon.numInteriorRings()):
                interior = polygon.interiorRing(i)
                if interior:
                    coords = " ".join([f"{v.x()},{v.y()},0" for v in interior.vertices()])
                    kml.append(
                        f'<innerBoundaryIs><LinearRing><coordinates>{coords}</coordinates></LinearRing></innerBoundaryIs>')

            kml.append('</Polygon>')

        elif geom_type == QgsWkbTypes.LineGeometry:
            line = geom.get()
            kml.append('<LineString>')
            coords = " ".join([f"{v.x()},{v.y()},0" for v in line.vertices()])
            kml.append(f'<coordinates>{coords}</coordinates>')
            kml.append('</LineString>')

        kml.extend(['</Placemark>', '</Document>', '</kml>'])

        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(kml))

    def load_output_files(self, output_files):

        layers_to_add = []
        for output_file in output_files:
            layer_name = os.path.basename(output_file)
            layer = QgsVectorLayer(output_file, layer_name, "ogr")
            if not layer.isValid():
                raise QgsProcessingException(f"Failed to load layer: {layer_name}")
            layers_to_add.append(layer)
        QgsProject.instance().addMapLayers(layers_to_add)

    def compress_files(self, output_file):
        base_name = os.path.splitext(output_file)[0]
        zip_output_file = base_name + "_kml.zip"
        with zipfile.ZipFile(zip_output_file, 'w') as zipf:
            zipf.write(output_file, os.path.basename(output_file))

    def name(self):
        return "ExportKMLstoDrone"

    def displayName(self):
        return tr("Export KML files to DJI Pilot")

    def group(self):
        return tr("Emi Tools")

    def groupId(self):
        return ""

    def shortHelpString(self):
        return tr("This algorithm exports each feature from a polygon or line layer to a separate KML file, compatible with software DJI Pilot.<br> To ensure compatibility with the DJI Pilot app, the &lt;Folder&gt; tag—automatically added by QGIS to structure KML content— is removed, as it is not supported by the application.")

    def createInstance(self):
        return emiToolsExportKmlRpa()
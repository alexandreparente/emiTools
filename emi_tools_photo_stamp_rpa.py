# -*- coding: utf-8 -*-

"""
/***************************************************************************
 emiTools
                                 A QGIS plugin
 This plugin compiles tools used by EMI-PB
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-10
        copyright            : (C) 2024 by Alexandre Parente Lima
        email                : alexandre.parente@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Alexandre Parente Lima'
__date__ = '2024-10-10'
__copyright__ = '(C) 2024 by Alexandre Parente Lima'

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import (QCoreApplication, Qt, QRect, QRectF, QDateTime, QVariant, QFileInfo)
from qgis.PyQt.QtGui import (QImage, QPainter, QFont, QColor, QFontMetrics, QFontDatabase)
from qgis.PyQt.QtSvg import QSvgRenderer
from qgis.PyQt.QtWidgets import QApplication
from qgis.core import (QgsProcessing,
                       QgsVectorFileWriter,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterField,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFolderDestination,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterString,
                       QgsProcessingParameterColor,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterNumber,
                       QgsProject,
                       QgsVectorLayer,
                       QgsFeature,
                       QgsProcessingException,
                       QgsWkbTypes,
                       QgsExifTools,
                       QgsCoordinateFormatter,
                       QgsFields,
                       QgsField,
                       QgsPoint,
                       QgsGeometry,
                       QgsPointXY)

import os
import tempfile
from .emi_tools_util import tr


class emiToolsStampPhotoRpa(QgsProcessingAlgorithm):
    INPUT_PHOTO = 'INPUT_PHOTO'
    OUTPUT_FOLDER = 'OUTPUT_FOLDER'
    STAMP_IMAGE = 'STAMP_IMAGE'
    INPUT_TEXT = 'INPUT_TEXT'
    METADATA_TO_STAMP = 'METADATA_TO_STAMP'
    FONT_COLOR = 'FONT_COLOR'
    FONT_SIZE = 'FONT_SIZE'
    FONT_NAME = 'FONT_NAME'
    POSITION = 'POSITION'

    POSITION_OPTIONS = ['Bottom Left', 'Bottom Right', 'Top Left', 'Top Right']

    METADATA_MAP = {
        'photo': 'Photo Path', 'filename': 'Filename', 'directory': 'Directory',
        'altitude': 'Altitude', 'direction': 'Direction', 'rotation': 'Rotation',
        'longitude': 'Longitude', 'latitude': 'Latitude', 'timestamp': 'DateTime',
        'coordinates': 'Coordinates', 'model': 'Model', 'CamReverse': 'CamReverse',
        'FlightPitchDegree': 'Flight Pitch Degree', 'FlightRollDegree': 'Flight Roll Degree',
        'FlightYawDegree': 'Flight Yaw Degree', 'GimbalPitchDegree': 'Gimbal Pitch Degree',
        'GimbalReverse': 'GimbalReverse', 'GimbalRollDegree': 'Gimbal Roll Degree',
        'GimbalYawDegree': 'Gimbal Yaw Degree', 'RelativeAltitude': 'Relative Altitude'
    }

    def get_translated_position_options(self):
        """Retorna uma lista de opções de posição traduzidas para a interface."""
        return [
            tr('Bottom Left'),
            tr('Bottom Right'),
            tr('Top Left'),
            tr('Top Right')
        ]

    def get_translated_metadata_map(self):
        """
        Retorna um dicionário mapeando chaves internas para nomes traduzidos.
        Este é o local central para todas as traduções de metadados.
        """
        return {
            'photo': tr('Photo Path'),
            'filename': tr('Filename'),
            'directory': tr('Directory'),
            'altitude': tr('Altitude'),
            'direction': tr('Direction'),
            'rotation': tr('Rotation'),
            'longitude': tr('Longitude'),
            'latitude': tr('Latitude'),
            'timestamp': tr('DateTime'),
            'coordinates': tr('Coordinates'),
            'model': tr('Model'),
            'CamReverse': tr('CamReverse'),
            'FlightPitchDegree': tr('Flight Pitch Degree'),
            'FlightRollDegree': tr('Flight Roll Degree'),
            'FlightYawDegree': tr('Flight Yaw Degree'),
            'GimbalPitchDegree': tr('Gimbal Pitch Degree'),
            'GimbalReverse': tr('GimbalReverse'),
            'GimbalRollDegree': tr('Gimbal Roll Degree'),
            'GimbalYawDegree': tr('Gimbal Yaw Degree'),
            'RelativeAltitude': tr('Relative Altitude')
        }

    def initAlgorithm(self, config=None):
        # Initializes the algorithm's parameters

        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT_PHOTO,
                tr('Input folder'),
                behavior=QgsProcessingParameterFile.Folder
            )
        )

        self.addParameter(
            QgsProcessingParameterFile(
                self.STAMP_IMAGE,
                tr('SVG Image'),
                extension='svg',
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.INPUT_TEXT,
                tr('Text'),
                defaultValue="",
                multiLine=True
            )
        )

        translated_map = self.get_translated_metadata_map()
        metadata_options_display = list(translated_map.values())

        untranslated_defaults = ['Model', 'DateTime', 'Coordinates', 'Altitude']
        default_indices = [list(self.METADATA_MAP.values()).index(opt) for opt in untranslated_defaults if
                           opt in self.METADATA_MAP.values()]

        self.addParameter(
            QgsProcessingParameterEnum(
                self.METADATA_TO_STAMP,
                tr('Metadata to stamp'),
                options=metadata_options_display,
                allowMultiple=True,
                defaultValue=default_indices
            )
        )

        font_db = QFontDatabase()
        fonts = font_db.families()

        # Get the default font from QGIS
        app = QApplication.instance()
        default_font = app.font().family()

        # Check if the default font is available on the system
        default_font_index = fonts.index(default_font) if default_font in fonts else 0

        # Add the Enum parameter to select the font
        self.addParameter(
            QgsProcessingParameterEnum(
                self.FONT_NAME,
                tr('Font'),
                options=fonts,
                defaultValue=default_font_index
            )
        )

        self.addParameter(
            QgsProcessingParameterColor(
                self.FONT_COLOR,
                tr('Font color'),
                defaultValue=QColor(255, 255, 0)
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.FONT_SIZE,
                tr('Font size'),
                defaultValue=60,
                minValue=1,
                maxValue=500
            )
        )

        # Return the translated options for display to the user
        def positionOptions():
            return [
                tr('Bottom Left'),
                tr('Bottom Right'),
                tr('Top Left'),
                tr('Top Right')
            ]

        # Calling the function to get the translated options
        self.addParameter(
            QgsProcessingParameterEnum(
                self.POSITION,
                tr('Position of text and image'),
                options=self.get_translated_position_options(),
                defaultValue=0
            )
        )

        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT_FOLDER,
                tr('Output folder')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        # Loads the input raster layers

        input_folder = self.parameterAsString(parameters, self.INPUT_PHOTO, context)

        # List the image files in the folder
        image_extensions = ('.jpg', '.jpeg', '.tif', '.tiff', '.png')
        input_photos = [os.path.join(input_folder, f) for f in os.listdir(input_folder) if
                        f.lower().endswith(image_extensions)]

        # Get output folder
        output_folder = self.parameterAsString(parameters, self.OUTPUT_FOLDER, context)
        if not output_folder: output_folder = tempfile.mkdtemp()
        if not os.path.exists(output_folder): os.makedirs(output_folder)

        svg_file_path = self.parameterAsFile(parameters, self.STAMP_IMAGE, context)

        # Collects text and style parameters
        input_text = self.parameterAsString(parameters, self.INPUT_TEXT, context)
        font_color = self.parameterAsColor(parameters, self.FONT_COLOR, context)
        font_size = self.parameterAsInt(parameters, self.FONT_SIZE, context)

        # get font
        font_index = self.parameterAsEnum(parameters, self.FONT_NAME, context)
        font_db = QFontDatabase()
        fonts = font_db.families()
        font_name = fonts[font_index]

        # Use the index to access the string (untranslated)
        position_index = self.parameterAsInt(parameters, self.POSITION, context)
        position = self.POSITION_OPTIONS[position_index]

        translated_map = self.get_translated_metadata_map()
        internal_keys = list(translated_map.keys())
        selected_indices = self.parameterAsEnums(parameters, self.METADATA_TO_STAMP, context)
        internal_keys_to_stamp = [internal_keys[i] for i in selected_indices]

        # Processes each selected image
        for raster_file_path in input_photos:
            input_qimage = QImage(raster_file_path)

            if input_qimage.isNull():
                feedback.pushWarning(tr("Failed to load input image: {}").format(raster_file_path))
                continue

            exif_data = self.get_exif_data(raster_file_path, feedback)

            # Transform the input_text into a list of lines while preserving empty paragraphs
            if input_text:
                lines_to_stamp = input_text.splitlines()
            else:
                lines_to_stamp = []

            # Add the selected metadata as separate lines (keeping empty lines if any)
            for key in internal_keys_to_stamp:
                value = exif_data.get(key)
                if value is not None:
                    friendly_name = translated_map.get(key, key)
                    if isinstance(value, float):
                        formatted_value = f"{value:.2f}"
                    else:
                        formatted_value = value
                    lines_to_stamp.append(f"{friendly_name}: {formatted_value}")

            self.insert_stamp(input_qimage, svg_file_path, font_color, font_size, position, font_name, lines_to_stamp,
                              feedback)
            output_image_path = self.save_image(input_qimage, raster_file_path, output_folder, feedback)

            self.insert_exif_data(output_image_path, exif_data.get('full_map', {}), feedback)
            feedback.pushInfo(tr(f"Image saved at {output_image_path}"))

        return {self.OUTPUT_FOLDER: output_folder}

    def get_exif_data(self, temp_file_path, feedback):
        exif_tools = QgsExifTools()
        data = {
            'photo': temp_file_path,
            'filename': os.path.basename(temp_file_path),
            'directory': os.path.dirname(temp_file_path)
        }
        tags = exif_tools.readTags(temp_file_path)
        data['full_map'] = tags

        def get_float(tag_name):
            val = tags.get(tag_name)
            try:
                return float(val) if val is not None else None
            except (ValueError, TypeError):
                return None

        if exif_tools.hasGeoTag(temp_file_path):
            geo_tag_result = exif_tools.getGeoTag(temp_file_path)
            if geo_tag_result and isinstance(geo_tag_result[0], QgsPoint):
                exif_point = geo_tag_result[0]
                data['latitude'] = exif_point.y()
                data['longitude'] = exif_point.x()
                lat_dms = QgsCoordinateFormatter.formatY(data['latitude'],
                                                         QgsCoordinateFormatter.FormatDegreesMinutesSeconds, 2)
                lon_dms = QgsCoordinateFormatter.formatX(data['longitude'],
                                                         QgsCoordinateFormatter.FormatDegreesMinutesSeconds, 2)
                data['coordinates'] = f"{lat_dms}, {lon_dms}"

        data['altitude'] = get_float('Exif.GPSInfo.GPSAltitude')
        data['direction'] = get_float('Exif.GPSInfo.GPSImgDirection')
        dt = tags.get('Exif.Photo.DateTimeOriginal')
        if isinstance(dt, QDateTime):
            data['timestamp'] = dt.toString("yyyy-MM-dd HH:mm:ss")
        data['model'] = tags.get('Exif.Image.Model')

        dji_fields = {
            'CamReverse': 'Xmp.drone-dji.CamReverse', 'FlightPitchDegree': 'Xmp.drone-dji.FlightPitchDegree',
            'FlightRollDegree': 'Xmp.drone-dji.FlightRollDegree', 'FlightYawDegree': 'Xmp.drone-dji.FlightYawDegree',
            'GimbalPitchDegree': 'Xmp.drone-dji.GimbalPitchDegree', 'GimbalReverse': 'Xmp.drone-dji.GimbalReverse',
            'GimbalRollDegree': 'Xmp.drone-dji.GimbalRollDegree', 'GimbalYawDegree': 'Xmp.drone-dji.GimbalYawDegree',
            'RelativeAltitude': 'Xmp.drone-dji.RelativeAltitude'
        }
        for key, tag in dji_fields.items():
            data[key] = get_float(tag)

        data['rotation'] = data.get('direction') or data.get('FlightYawDegree')
        return data

    def insert_stamp(self, input_qimage, svg_file_path, font_color, font_size, position, font_name, lines_to_stamp,
                     feedback):
        painter = QPainter(input_qimage)

        # Input image dimensions
        image_width = painter.device().width()
        image_height = painter.device().height()

        # Set font
        font = QFont(font_name, font_size)
        painter.setFont(font)

        # Ensure that no None entries remain
        full_text_lines = [line if line is not None else '' for line in lines_to_stamp]

        # Create the final text preserving line breaks and empty paragraphs
        full_text = "\n".join(full_text_lines)

        if (not full_text.strip()) and not svg_file_path:
            painter.end()
            return

        metrics = QFontMetrics(font)
        line_spacing = metrics.lineSpacing()

        # Count all lines, including empty ones
        num_lines = max(1, len(full_text.split('\n')))
        total_text_height = line_spacing * num_lines

        image_offset = 50

        svg_width, svg_height = 0, 0
        svg_renderer = None
        if svg_file_path:
            svg_renderer = QSvgRenderer(svg_file_path)
            if svg_renderer.isValid():
                svg_size = svg_renderer.defaultSize()
                if svg_size.height() > 0:
                    svg_aspect_ratio = svg_size.width() / svg_size.height()
                    svg_height = total_text_height if total_text_height > 0 else 100
                    svg_width = svg_height * svg_aspect_ratio
            else:
                feedback.pushWarning(tr(f"Failed to load SVG file: {svg_file_path}"))
                svg_renderer = None

        text_width = image_width - (2 * image_offset) - (svg_width + image_offset if svg_renderer else 0)
        h_offset = svg_width + image_offset if svg_renderer else 0

        if position == 'Bottom Left':
            alignment = Qt.AlignLeft | Qt.AlignBottom
            svg_y_base = image_height - image_offset - (max(total_text_height, svg_height))
            svg_x, svg_y = image_offset, svg_y_base + (max(total_text_height, svg_height) - svg_height) / 2
            text_x, text_y = svg_x + h_offset, image_height - image_offset - total_text_height
        elif position == 'Bottom Right':
            alignment = Qt.AlignRight | Qt.AlignBottom
            svg_y_base = image_height - image_offset - (max(total_text_height, svg_height))
            svg_x, svg_y = image_width - image_offset - svg_width, svg_y_base + (
                    max(total_text_height, svg_height) - svg_height) / 2
            text_x, text_y = image_offset, image_height - image_offset - total_text_height
        elif position == 'Top Left':
            alignment = Qt.AlignLeft | Qt.AlignTop
            svg_y_base = image_offset
            svg_x, svg_y = image_offset, svg_y_base + (max(total_text_height, svg_height) - svg_height) / 2
            text_x, text_y = svg_x + h_offset, image_offset
        else:  # Top Right
            alignment = Qt.AlignRight | Qt.AlignTop
            svg_y_base = image_offset
            svg_x, svg_y = image_width - image_offset - svg_width, svg_y_base + (
                    max(total_text_height, svg_height) - svg_height) / 2
            text_x, text_y = image_offset, image_offset

        text_rect = QRect(int(text_x), int(text_y), int(text_width), int(total_text_height))
        painter.setPen(QColor(font_color))
        painter.drawText(text_rect, alignment, full_text)

        if svg_renderer:
            svg_rect = QRectF(svg_x, svg_y, svg_width, svg_height)
            svg_renderer.render(painter, svg_rect)

        painter.end()

    def insert_exif_data(self, temp_file_path, full_map_exif, feedback):
        if not full_map_exif: return
        exif_tools = QgsExifTools()

        # Iterate over full_map_exif and tag each EXIF tag into the image
        for tag, value in full_map_exif.items():
            try:
                exif_tools.tagImage(temp_file_path, tag, value)
            except Exception as e:
                feedback.pushInfo(tr(f"Could not write tag {tag}: {str(e)}"))

    def save_image(self, input_qimage, raster_file_path, output_folder, feedback):
        raster_file_info = QFileInfo(raster_file_path)
        output_image_path = os.path.join(output_folder,
                                         raster_file_info.baseName() + '_stamped.' + raster_file_info.suffix())
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        # Check if the image was loaded correctly
        if input_qimage.isNull():
            raise QgsProcessingException("Failed to load the temporary image.")

        # Save the processed image to the specified output folder
        if input_qimage.save(output_image_path):
            return output_image_path
        else:
            raise QgsProcessingException("Failed to save the processed image.")

    def create_points_layer(self, coordinates_list):
        pass

    def name(self):
        return "emiToolsStampPhotoRpa"

    def displayName(self):
        return tr("Stamp text and image on the photo")

    def group(self):
        return tr("Emi Tools")

    def groupId(self):
        return ""

    def shortHelpString(self):
        return tr(
            "This algorithm inscribes text and an optional SVG logo onto JPEG or PNG images using EXIF metadata such as coordinates, altitude, date, and camera model. "
            "The stamp position, font style, and color are customizable. The processed images are saved in the output folder, preserving EXIF data."
        )

    def createInstance(self):
        return emiToolsStampPhotoRpa()

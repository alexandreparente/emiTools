# -*- coding: utf-8 -*-

"""
/***************************************************************************
 emiTools
                                 A QGIS plugin
 This plugin compiles tools used by EMI-PB
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-10
        copyright            : (C) 2024 by Alexandre Parente Lima
        email                : alexandre.parente@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Alexandre Parente Lima'
__date__ = '2024-10-10'
__copyright__ = '(C) 2024 by Alexandre Parente Lima'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

# -*- coding: utf-8 -*-
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsVectorFileWriter,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterField, 
                       QgsProcessingParameterBoolean,
                       QgsProcessingMultiStepFeedback, 
                       QgsProcessingParameterFile,
                       QgsProject,
                       QgsVectorLayer,
                       QgsFeature, 
                       QgsProcessingException,
                       QgsWkbTypes)

import os
import zipfile

def tr(string):
    return QCoreApplication.translate('@default', string)


class emiToolsExportKmlRpa(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):
        # Input layer parameter using QgsProcessingParameterFeatureSource
        self.addParameter(QgsProcessingParameterFeatureSource('layer', tr('Layer name:'), 
                    [QgsProcessing.TypeVectorPolygon, QgsProcessing.TypeVectorLine]))

        # Input field parameter to select a field for naming the exported files
        self.addParameter(QgsProcessingParameterField('export_field', tr('Field to use for export file names:'),
                    '', 'layer', optional=True))

        # Output folder parameter
        default_output_folder = os.path.expanduser("~")
        self.addParameter(QgsProcessingParameterFile('output_folder', tr('Output folder:'), 
                    behavior=QgsProcessingParameterFile.Folder, defaultValue=default_output_folder))

        # Option to compress the output
        self.addParameter(QgsProcessingParameterBoolean('compress_output', tr('Compress output file copy (.zip)'), 
                    defaultValue=False))

        # Option to load the output into the project
        self.addParameter(QgsProcessingParameterBoolean('load_output', tr('Open output files after executing the algorithm'), 
                    defaultValue=True))

    def processAlgorithm(self, parameters, context, feedback):
        feedback = QgsProcessingMultiStepFeedback(1, feedback)

        # Get the input layer as a feature source
        layer = self.parameterAsSource(parameters, 'layer', context)
        if layer is None:
            raise QgsProcessingException(self.invalidSourceError(parameters, 'layer'))

        # Get the field selected by the user
        export_field = self.parameterAsString(parameters, 'export_field', context)
        
        # Get other parameters
        output_folder = self.parameterAsFile(parameters, 'output_folder', context)
        compress_output = self.parameterAsBoolean(parameters, 'compress_output', context)
        load_output = self.parameterAsBoolean(parameters, 'load_output', context)

        # Itera sobre as feições e exporta cada uma como um arquivo KML individual
        for i, feature in enumerate(layer.getFeatures()):
            # Usa o valor do campo para nomeação ou um nome padrão
            field_value = feature[export_field] if export_field else f"{layer.sourceName()}_{i+1}"
        
            # Obtém a geometria da feição e garante que ela é válida
            geometry = feature.geometry()
            if not geometry or geometry.isEmpty():        
                feedback.pushInfo(f"Skipping feature {i+1}: No valid geometry found.")
                continue
        
            # Verifica se a geometria é multipart e converte para singlepart
            geometries = [geometry]  # Inicia com a geometria original
            if geometry.isMultipart():
                geometries = geometry.asGeometryCollection()  # Divide as partes da geometria multipart
        
            # Processa cada parte da geometria (para multipart)
            for j, singlepart_geometry in enumerate(geometries):
                # Ajusta o nome do arquivo para multipartes, se necessário
                part_suffix = f"_{j+1}" if geometry.isMultipart() else ""
        
                # Determina o tipo de geometria da feição
                geometry_type = singlepart_geometry.wkbType()
                feedback.pushInfo(f"Geometry type for the feature '{field_value}{part_suffix}': {geometry_type}")
        
                # Cria uma camada temporária baseada no tipo de geometria
                if QgsWkbTypes.geometryType(geometry_type) == QgsWkbTypes.LineGeometry:  # LineString
                    temp_layer = QgsVectorLayer("LineString?crs=EPSG:4326", f"{field_value}{part_suffix}", "memory")        
                elif QgsWkbTypes.geometryType(geometry_type) == QgsWkbTypes.PolygonGeometry:  # Polygon
                    temp_layer = QgsVectorLayer("Polygon?crs=EPSG:4326", f"{field_value}{part_suffix}", "memory")
                else:
                    raise QgsProcessingException(f"Unsupported geometry type: {QgsWkbTypes.displayString(geometry_type)}")
        
                # Adiciona a feição à camada temporária
                temp_layer_data_provider = temp_layer.dataProvider()
                temp_layer_data_provider.addAttributes(layer.fields())
                temp_layer.updateFields()        
        
                # Cria uma nova feição com a geometria singlepart
                new_feature = QgsFeature()
                new_feature.setGeometry(singlepart_geometry)  # Define a geometria singlepart
                new_feature.setAttributes(feature.attributes())  # Atribui os atributos da feição original
                temp_layer_data_provider.addFeature(new_feature)
        
                # Define opções para salvar a camada
                options = QgsVectorFileWriter.SaveVectorOptions()
                options.driverName = 'KML'
                options.fileEncoding = 'UTF-8'
                options.fieldNameSource = QgsVectorFileWriter.Original
        
                # Obter o contexto de transformação
                transform_context = QgsProject.instance().transformContext()
        
                # Escreve a feição em um arquivo KML
                output_file = os.path.join(output_folder, f"{field_value}{part_suffix}.kml")
                error = QgsVectorFileWriter.writeAsVectorFormatV3(temp_layer, output_file, transform_context, options)
        
                # Verifica se ocorreu algum erro        
                if error[0] != QgsVectorFileWriter.NoError:
                    raise QgsProcessingException(f"Erro ao salvar o arquivo KML: {error[0]}")
        
                # Remove as tags <Folder> e adiciona a tag <name>
                self.edit_kml_tags(output_file, f"{field_value}{part_suffix}")
        
                # Comprime o arquivo KML, se necessário
                if compress_output:
                    zip_output_file = output_file + ".zip"
                    with zipfile.ZipFile(zip_output_file, 'w') as zipf:
                        zipf.write(output_file, os.path.basename(output_file))
                    output_file = zip_output_file
        
                # Carrega o arquivo no projeto, se selecionado
                if load_output:
                    QgsProject.instance().addMapLayer(QgsVectorLayer(output_file, os.path.basename(output_file), "ogr"))

        return {'output_folder': output_folder}


    # Removes the <Folder> tag from the KML file and adds the <name> tag inside each <Placemark>
    def edit_kml_tags(self, kml_file, field_value):
        """Remove the <Folder> tags from the KML file and insert a <name> tag with the field_value for each <Placemark>."""
        with open(kml_file, 'r', encoding='utf-8') as file:
            lines = file.readlines()
    
        with open(kml_file, 'w', encoding='utf-8') as file:
            for line in lines:
                # Remove the <Folder> and </Folder> tags
                if '<Folder>' in line or '</Folder>' in line:
                    continue
                # When a <Placemark> is found, add a <name> tag right after it with the field_value
                if '<Placemark>' in line:
                    file.write(line)
                    file.write(f"<name>{field_value}</name>\n")  # Add the <name> tag with field_value
                else:
                    file.write(line)

    def name(self):
        return tr("Export KML to RPA")

    def displayName(self):
        return tr("Export KML to RPA")

    def group(self):
        return tr("Emi Functions")

    def groupId(self):
        return ""

    def createInstance(self):
        return emiToolsExportKmlRpa()


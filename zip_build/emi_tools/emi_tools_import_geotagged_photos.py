# -*- coding: utf-8 -*-

"""
/***************************************************************************
 emiTools
                                 A QGIS plugin
 This plugin compiles tools used by EMI-PB
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-10
        copyright            : (C) 2024 by Alexandre Parente Lima
        email                : alexandre.parente@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Alexandre Parente Lima'
__date__ = '2024-10-10'
__copyright__ = '(C) 2024 by Alexandre Parente Lima'

from qgis.core import (QgsApplication,
                       QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterMultipleLayers,
                       QgsProcessingParameterVectorDestination,
                       QgsProcessingParameterBoolean,
                       QgsProcessingException,
                       QgsExifTools,
                       QgsCoordinateFormatter,
                       QgsFields,
                       QgsField,
                       QgsFeature,
                       QgsVectorLayer,
                       QgsPointXY,
                       QgsVectorFileWriter,
                       QgsSingleSymbolRenderer,
                       QgsPoint,
                       QgsGeometry,
                       QgsRuleBasedRenderer,
                       QgsSvgMarkerSymbolLayer,
                       QgsMarkerSymbol,
                       QgsSymbolLayer,
                       QgsProperty,
                       QgsEditorWidgetSetup,
                       QgsWkbTypes,
                       QgsLayerDefinition,
                       QgsProject)

from qgis.PyQt.QtCore import (QCoreApplication,
                              QDateTime,
                              QVariant)

from qgis.PyQt.QtGui import QImage

import os


def tr(string):
    return QCoreApplication.translate('@default', string)

class emiToolsImportGeotaggedPhotos(QgsProcessingAlgorithm):
    INPUT_IMAGE = 'INPUT_IMAGE'
    OUTPUT_FILE = 'OUTPUT_FILE'
    EXPORT_STYLE = 'EXPORT_STYLE'
    NO_EXTRACT_DJI_XMP = 'NO_EXTRACT_DJI_XMP'

    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterMultipleLayers(self.INPUT_IMAGE, tr('Input Images'),
                                                               layerType=QgsProcessing.TypeRaster))

        self.addParameter(QgsProcessingParameterVectorDestination(self.OUTPUT_FILE, tr('Output file')))

        # Adds a checkbox to export the DJI XMP metadata
        self.addParameter(QgsProcessingParameterBoolean(self.NO_EXTRACT_DJI_XMP, tr('Do not import XMP tags used by DJI'), defaultValue=False))

                #Adds a checkbox to export the style
        self.addParameter(QgsProcessingParameterBoolean(self.EXPORT_STYLE, tr('Export the Layer Definition file (QLR)'),
                                                        defaultValue=True))

    def processAlgorithm(self, parameters, context, feedback):
        input_images = self.parameterAsLayerList(parameters, self.INPUT_IMAGE, context)
        output_file = self.parameterAsOutputLayer(parameters, self.OUTPUT_FILE, context)
        export_style = self.parameterAsBool(parameters, self.EXPORT_STYLE, context)
        no_extract_dji_xmp = self.parameterAsBool(parameters, self.NO_EXTRACT_DJI_XMP, context)

        feature_exif_dict = {}
        erro_feature_exif_dict = {}

        for input_image in input_images:
            raster_file_path = input_image.dataProvider().dataSourceUri()
            input_qimage = QImage(raster_file_path)

            if input_qimage.isNull():
                raise QgsProcessingException(tr("Failed to load input image."))

            exif_dict = {
                'photo': raster_file_path,
                'filename': input_image.name(),
                'directory':os.path.dirname(raster_file_path),
                **self.get_exif_data(raster_file_path, no_extract_dji_xmp, feedback)
            }

            # Adds the dictionary to feature_exif_dict
            if exif_dict.get('latitude') and exif_dict.get('longitude'):
                feature_exif_dict[input_image.name()] = exif_dict
            else:
                erro_feature_exif_dict[input_image.name()] = exif_dict

        #create the point layer
        point_layer = self.create_points_layer(feature_exif_dict, output_file)

        #exports the layer to a file
        export_layer = self.export_output_file(point_layer, output_file)

        #loads the layer into QGIS
        layer_loaded = self.load_output_file(export_layer)

        #creates the Layer Definition File (QLR)
        if export_style:
            self.export_definition_file(output_file, layer_loaded)

        feedback.pushInfo(tr(
            f"A total of {len(feature_exif_dict)} images with geotags and {len(erro_feature_exif_dict)} images without geotags were identified."))
        return {self.OUTPUT_FILE: export_layer}

    def get_exif_data(self, temp_file_path, no_extract_dji_xmp, feedback):
        """
        Extracts EXIF and XMP metadata from an image file.

        Parameters:
        temp_file_path (str): The path to the temporary file containing the image.
        feedback (QgsFeedback): A feedback object to log messages.

        Returns:
        dict: A dictionary containing extracted EXIF and XMP data.
        """
        exif_tools = QgsExifTools()

        # Check if the file has valid geotag information
        if not exif_tools.hasGeoTag(temp_file_path):
            #feedback.pushInfo("No valid geotag found.")
            return {}

        #all_tags = exif_tools.readTags(temp_file_path)
        #print(f'{all_tags}')

        # Retrieve the geotag information
        geo_tag_result = exif_tools.getGeoTag(temp_file_path)
        exif_geo_tag = geo_tag_result[0]

        # Initialize coordinate strings
        exif_coordinates_str = None

        # If a valid geotag is found, format latitude and longitude to DMS format
        if exif_geo_tag and isinstance(exif_geo_tag, QgsPoint):
            exif_latitude = exif_geo_tag.y()
            exif_longitude = exif_geo_tag.x()
            latitude_dms = QgsCoordinateFormatter.formatY(
                exif_latitude, QgsCoordinateFormatter.FormatDegreesMinutesSeconds, 2)
            longitude_dms = QgsCoordinateFormatter.formatX(
                exif_longitude, QgsCoordinateFormatter.FormatDegreesMinutesSeconds, 2)
            exif_coordinates_str = f"{latitude_dms}, {longitude_dms}"
        else:
            latitude_dms = None
            longitude_dms = None
            exif_coordinates_str = None

        # Extract the original datetime of the image
        exif_datetime = exif_tools.readTag(temp_file_path, 'Exif.Photo.DateTimeOriginal')
        exif_datetime_str = exif_datetime.toString("yyyy-MM-dd HH:mm:ss") if isinstance(exif_datetime,
                                                                                        QDateTime) else None
        # Extract the camera model
        exif_model_str = exif_tools.readTag(temp_file_path, 'Exif.Image.Model') or None

        # Extract GPS altitude and converting to float
        raw_exif_altitude = exif_tools.readTag(temp_file_path, 'Exif.GPSInfo.GPSAltitude')
        exif_altitude = float(raw_exif_altitude) if raw_exif_altitude else None

        # Extract GPS direction and converting to float
        raw_exif_direction = exif_tools.readTag(temp_file_path, 'Exif.GPSInfo.GPSImgDirection')
        exif_direction = float(raw_exif_direction) if raw_exif_direction else None

        # Extract DJI-specific XMP tags for drone data
        if not no_extract_dji_xmp:
            raw_CamReverse = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.CamReverse')
            xmp_CamReverse = float(raw_CamReverse) if raw_CamReverse else None

            raw_FlightPitchDegree = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.FlightPitchDegree')
            xmp_FlightPitchDegree = float(raw_FlightPitchDegree) if raw_FlightPitchDegree else None

            raw_FlightRollDegree = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.FlightRollDegree')
            xmp_FlightRollDegree = float(raw_FlightRollDegree) if raw_FlightRollDegree else None

            raw_FlightYawDegree = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.FlightYawDegree')
            xmp_FlightYawDegree = float(raw_FlightYawDegree) if raw_FlightYawDegree else None

            raw_GimbalPitchDegree = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.GimbalPitchDegree')
            xmp_GimbalPitchDegree = float(raw_GimbalPitchDegree) if raw_GimbalPitchDegree else None

            raw_GimbalReverse = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.GimbalReverse')
            xmp_GimbalReverse = float(raw_GimbalReverse) if raw_GimbalReverse else None

            raw_GimbalRollDegree = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.GimbalRollDegree')
            xmp_GimbalRollDegree = float(raw_GimbalRollDegree) if raw_GimbalRollDegree else None

            raw_GimbalYawDegree = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.GimbalYawDegree')
            xmp_GimbalYawDegree = float(raw_GimbalYawDegree) if raw_GimbalYawDegree else None

            raw_RelativeAltitude = exif_tools.readTag(temp_file_path, 'Xmp.drone-dji.RelativeAltitude')
            xmp_RelativeAltitude = float(raw_RelativeAltitude) if raw_RelativeAltitude else None

        # Key created to set the angle property for svg_marker symbology
        if exif_direction is not None:
            symbol_rotation = exif_direction
        elif not no_extract_dji_xmp and xmp_FlightYawDegree is not None:
            symbol_rotation = xmp_FlightYawDegree
        else:
            symbol_rotation = None

        # Create a dictionary with all extracted EXIF and XMP metadata
        exif_dict = {
            'altitude': exif_altitude,
            'direction': exif_direction,
            'rotation': symbol_rotation,  # Key created to set the angle property for svg_marker symbology
            'longitude': exif_longitude,  # Required key for creating a points layer
            'latitude': exif_latitude,  # Required key for creating a points layer
            'timestamp': exif_datetime_str,
            'coordinates': exif_coordinates_str,
            'model': exif_model_str
        }

        # Create a dictionary with XMP metadata
        if not no_extract_dji_xmp:
            exif_dict.update({
                'CamReverse': xmp_CamReverse,
                'FlightPitchDegree': xmp_FlightPitchDegree,
                'FlightRollDegree': xmp_FlightRollDegree,
                'FlightYawDegree': xmp_FlightYawDegree,
                'GimbalPitchDegree': xmp_GimbalPitchDegree,
                'GimbalReverse': xmp_GimbalReverse,
                'GimbalRollDegree': xmp_GimbalRollDegree,
                'GimbalYawDegree': xmp_GimbalYawDegree,
                'RelativeAltitude': xmp_RelativeAltitude
            })

        return exif_dict

    def create_points_layer(self, feature_exif_dict, output_file):
        # Defining the fields of the point layer dynamically
        fields = QgsFields()

        # Iterating over the dictionary to define the fields based on the keys and value types
        for key, exif_data in feature_exif_dict.items():
            for sub_key, value in exif_data.items():
                if isinstance(value, int):
                    fields.append(QgsField(sub_key, QVariant.Int))
                elif isinstance(value, float):
                    fields.append(QgsField(sub_key, QVariant.Double))
                else:
                    fields.append(QgsField(sub_key, QVariant.String))

        # Creating the point layer in memory
        point_layer = QgsVectorLayer("Point?crs=EPSG:4326", "Pontos Imagens", "memory")
        provider = point_layer.dataProvider()
        provider.addAttributes(fields)
        point_layer.updateFields()

        # Iterates over the keys and values of exif_data to dynamically add the attributes
        for image_name, exif_data in feature_exif_dict.items():
            attributes = []

            # Iterates over the keys and values of exif_data to dynamically add the attributes
            for sub_key, value in exif_data.items():
                attributes.append(value)

            # Extracting latitude and longitude
            exif_latitude = exif_data.get('latitude')
            exif_longitude = exif_data.get('longitude')

            # Adds the geometry if the coordinates are available
            if exif_latitude is not None and exif_longitude is not None:
                point = QgsPointXY(exif_longitude, exif_latitude)
                feature = QgsFeature()
                feature.setGeometry(QgsGeometry.fromPointXY(point))
                feature.setAttributes(attributes)
                provider.addFeature(feature)

        point_layer.updateExtents()

        return point_layer

    def export_output_file(self, point_layer, output_file):
        # Extracts the driverName based on the file format in the output_file input
        driver_name = QgsVectorFileWriter.driverForExtension(os.path.splitext(output_file)[1][1:])

        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = driver_name
        options.fileEncoding = 'UTF-8'
        transform_context = QgsProject.instance().transformContext()

        # Saves the file in the specified format
        error = QgsVectorFileWriter.writeAsVectorFormatV3(point_layer, output_file, transform_context, options)
        if error[0] != QgsVectorFileWriter.NoError:
            raise QgsProcessingException(f"Error saving the file: {error[1]}")

        return output_file

    def load_output_file(self, output_file):
        if not output_file:
            raise QgsProcessingException("No output file was specified.")

        # Define the paths to the SVG symbols used for rendering
        svg_path_arrow = os.path.join(QgsApplication.svgPaths()[0], 'arrows', 'Arrow_01.svg')
        svg_path_point = os.path.join(QgsApplication.svgPaths()[0], 'gpsicons', 'city_medium.svg')

        # Load the vector layer
        layer = QgsVectorLayer(output_file, os.path.basename(output_file), "ogr")
        if not layer.isValid():
            raise QgsProcessingException(f"Failed to load the output file: {output_file}")

        # Create symbol for points WITH direction (rotation based on 'rotation' field)
        symbol_arrow = QgsMarkerSymbol.defaultSymbol(QgsWkbTypes.PointGeometry)
        svg_marker_arrow = QgsSvgMarkerSymbolLayer(svg_path_arrow)
        svg_marker_arrow.setDataDefinedProperty(QgsSymbolLayer.PropertyAngle, QgsProperty.fromField('rotation'))
        symbol_arrow.changeSymbolLayer(0, svg_marker_arrow)

        # Symbol for points WITHOUT rotation
        symbol_point = QgsMarkerSymbol.defaultSymbol(QgsWkbTypes.PointGeometry)
        svg_marker_point = QgsSvgMarkerSymbolLayer(svg_path_point)
        symbol_point.changeSymbolLayer(0, svg_marker_point)

        # Create the root rule for rule-based rendering
        root_rule = QgsRuleBasedRenderer.Rule(None)

        # Rule for features where 'rotation' is null or empty
        rule1 = QgsRuleBasedRenderer.Rule(symbol_point)
        rule1.setLabel('Photos without direction')
        rule1.setFilterExpression('is_empty_or_null("rotation")')
        root_rule.appendChild(rule1)

        # Rule for features with valid 'rotation' values (directional)
        rule2 = QgsRuleBasedRenderer.Rule(symbol_arrow)
        rule2.setLabel('Photos without direction')
        rule2.setIsElse(True)
        root_rule.appendChild(rule2)

        # Apply the rule-based renderer to the layer
        renderer = QgsRuleBasedRenderer(root_rule)
        layer.setRenderer(renderer)

       # Add the layer to the project
        QgsProject.instance().addMapLayer(layer, False)
        QgsProject.instance().layerTreeRoot().addLayer(layer)

        # Set the HTML template for the Map Tip with a thumbnail preview
        expression = """
                         <tr>
                            <th>[%"filename"%]</th>
                         </tr> 
                         <tr>
                            <th><img src="file:///[%"photo"%]" width="350" height="250"></th>
                         </tr>
                       """
        layer.setMapTipTemplate(expression)

        # Configure the edit form widget for the 'photo' field
        field_name = 'photo'

        config = {'DocumentViewer': 1,
                  'FileWidget': True,
                  'FullUrl': True,
                  'UseLink': True}
        type = 'ExternalResource'
        fields = layer.fields()
        field_idx = fields.indexOf(field_name)
        widget_setup = QgsEditorWidgetSetup(type,config)
        layer.setEditorWidgetSetup(field_idx, widget_setup)

        return layer

    def load_output_file1(self, output_file):

        # symbol definition
        svg_path = os.path.join(QgsApplication.svgPaths()[0], 'arrows', 'Arrow_01.svg')
        symbol = QgsMarkerSymbol.defaultSymbol(QgsWkbTypes.PointGeometry)
        svg_marker = QgsSvgMarkerSymbolLayer(svg_path)
        svg_marker.setDataDefinedProperty(QgsSymbolLayer.PropertyAngle, QgsProperty.fromField('rotation'))
        symbol.changeSymbolLayer(0, svg_marker)

        # Gets the QGIS project instance and the root node of the LayerTree
        root = QgsProject.instance().layerTreeRoot()

        if output_file:
            # Loads the vector layer from the output file
            layer = QgsVectorLayer(output_file, os.path.basename(output_file), "ogr")
            if not layer.isValid():
                raise QgsProcessingException(f"Failed to load the output file.: {output_file}")

            # Checks if the layer was loaded successfully
            if symbol:
                renderer = QgsSingleSymbolRenderer(symbol)
                layer.setRenderer(renderer)

            #Adds the layer to the project without making it visible initially (False)
            QgsProject.instance().addMapLayer(layer, False)
            # Adds the layer to the root node, allowing it to be found in the LayerTree
            root.addLayer(layer)

            # Returns the loaded layer for potential further use
            return layer
        else:
            # Raises an exception if no output file is specified
            raise QgsProcessingException("No output file was specified.")

    def export_definition_file(self, output_file, layer_loaded):
        # Defines the same path as the exported file for the .qlr file
        base_path, _ = os.path.splitext(output_file)
        qlr_file_path = f"{base_path}.qlr"

        # Finds the corresponding layer node in the layer tree based on the layer's ID
        layer_tree_node = QgsProject.instance().layerTreeRoot().findLayer(layer_loaded.id())

        if not layer_tree_node:
            # Raises an exception if the layer node is not found in the layer tree
            raise QgsProcessingException(f"Layer node not found in the layer tree (ID: {layer_loaded.id()}).")

        # Exports the layer definition to the .qlr file
        try:
            QgsLayerDefinition.exportLayerDefinition(qlr_file_path, [layer_tree_node])
            print(f'QLR file exported to: {qlr_file_path}')
        except Exception as e:
            # Raises an exception if an error occurs during the export process
            raise QgsProcessingException(f"Error exporting the QLR file: {str(e)}")

        # Returns the path of the exported .qlr file
        return qlr_file_path

    def name(self):
        return 'emiToolsImportGeotaggedPhotos'

    def displayName(self):
        return tr('Import geotagged photos from DJI drones')

    def group(self):
        return tr("Emi Tools")

    def groupId(self):
        return ""

    def createInstance(self):
        return emiToolsImportGeotaggedPhotos()
